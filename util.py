# %% [markdown]
# Part 2: Web-Based Trading System
# This section focuses on developing a fully functional web-based trading system that
# integrates the machine learning model and API wrapper into an interactive user interface.
# The goal is to provide a seamless experience for users to analyze market trends and view
# the model-generated signals generated by your ML backend. Additionally, the system must
# be deployed to a cloud platform to ensure accessibility and scalability. Emphasis will be
# placed on user experience and efficient data retrieval.
# 2.1 Python API Wrapper for SimFin
# Students will construct a Python API wrapper to interact with SimFin. The goal is to simplify
# the interaction with the API just by using Python. This wrapper consists of a set of classes
# to retrieve share prices or any other useful information.
# Requirements
# • Implement an object-oriented code to extract data from SimFin.
# • The library must allow users to retrieve stock price data for specified companies in
# the specified period.
# Instructions and suggestions
# 1. Define the structure of the API. Here I provide an example of a simple Python
# wrapper for the API. Take it as a suggestion and simplify or complicate it as you
# consider.
# 1. Build a class PySimFin with the following capabilities.
# 1. Constructor. This will create a new instance for the class to interact
# with the API. In this constructor, you can initialize the base endpoint
# and the header with the “api-key”
# 2. get_share_prices (ticker: str, start: str, end: str). This method will
# return DataFrame with all prices for the provided ticker in the
# provided time range.
# 3. get_financial_statement (ticker: str, start: str, end: str). This method
# will return DataFrame with financial statements for the ticker
# provided in the provided time range.
# 

# %%
import requests
import pandas as pd

class PySimFin():
    BASE_URL = "https://backend.simfin.com/api/v3/"  # Correct Base API URL

    def __init__(self, api_key: str):
        """
        Initialize the PySimFin client with the provided API key.
        """
        self.api_key = api_key
        self.headers = {"Authorization": f"{self.api_key}"}  # Use Bearer token

    def _get(self, endpoint: str, params: dict = None):
        """
        Internal method to send a GET request to SimFin API.
        """
        url = self.BASE_URL + endpoint
        response = requests.get(url, headers=self.headers, params=params)

        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error {response.status_code}: {response.text}")
            return None

    def get_sim_id(self, ticker: str):
        """
        Fetch SimFin ID for a given ticker.
        """
        endpoint = "companies/general/verbose"
        params = {"ticker": ticker}
        data = self._get(endpoint, params)[0]
        print(data)
        if data and "id" in data:
            return data["id"]
        return None

    def get_share_prices(self, ticker: str, start: str, end: str):
        """
        Fetch historical share prices for a given ticker and time range.
        Returns a DataFrame.
        """
        sim_id = self.get_sim_id(ticker)
        if not sim_id:
            print(f"Error: Could not find SimFin ID for ticker {ticker}")
            return None

        endpoint = f"companies/prices/compact"
        params = {"id": sim_id, "start": start, "end": end}
        data = self._get(endpoint, params)
        print(data)
        # Extract columns and data
        columns = data[0]["columns"]
        data = data[0]["data"]

        # Create DataFrame
        df = pd.DataFrame(data, columns=columns)

        # Select only 'Date' and 'Last Closing Price' columns
        #df = df[["Date", "Last Closing Price"]]

        # Convert 'Date' column to datetime format
        df["Date"] = pd.to_datetime(df["Date"])

        
        return df
        

    def get_financial_statement(self, ticker: str, start: str, end: str):
        """
        Fetch financial statements (Income, Balance Sheet, Cash Flow) for a given ticker and time range.
        Returns a DataFrame.
        """
        # API endpoint
        url = f"https://backend.simfin.com/api/v3/companies/statements/compact?ticker={ticker}&statements=PL,CF,BS&period=&start={start}&end={end}"

        # API headers with authorization
        headers = {
            "accept": "application/json",
            "Authorization": "79f8076c-cdc4-4ffe-9827-a82f92215739"  # Replace with your valid API key
        }

        # Fetch data from the API
        response = requests.get(url, headers=headers)
        json_data = response.json()

        # Create an empty list to store the data
        statement_data = []

        # Extract statement and data from JSON
        for company in json_data:
            for stmt in company['statements']:
                statement_type = stmt['statement']
                columns = stmt['columns']
                # Iterate over all rows in the data list
                for data_row in stmt['data']:
                    # Create a dictionary with statement type and its data
                    row_dict = {'Statement': statement_type}
                    row_dict.update(dict(zip(columns, data_row)))
                    statement_data.append(row_dict)

        df = pd.DataFrame(statement_data)
        df["Report Date"] = pd.to_datetime(df["Report Date"], errors="coerce")

        return df
    
    def merge_data(self, prices_df, financials_df):
        """
        Merge share prices and financial statements based on the closest available dates.
        """
        if prices_df is None or financials_df is None:
            print("Error: One of the datasets is missing.")
            return None

        # Ensure datetime format for merging
        prices_df = prices_df.sort_values("Date")
        financials_df = financials_df.sort_values("Report Date")

        # Merge on closest available date
        merged_df = pd.merge_asof(prices_df, financials_df, left_on="Date", right_on="Report Date", direction="backward")
        return merged_df

    def add_technical_indicators(self, df):
        """
        Add technical indicators (SMA, RSI) to the dataset.
        """
        df["SMA_5"] = df["Last Closing Price"].rolling(window=5).mean()
        df["SMA_10"] = df["Last Closing Price"].rolling(window=10).mean()
        df["RSI_14"] = self.compute_rsi(df["Last Closing Price"], 14)
        return df
    
    def rename_columns(self, df):
        """
        Rename columns in the DataFrame to match expected names.
        """
        df = df.rename(columns={
            "Opening Price": "Open",
            "Highest Price": "High",
            "Lowest Price": "Low",
            "Last Closing Price": "Close",
            "Adjusted Closing Price": "Adj. Close",
            "Trading Volume": "Volume",
            "Dividend Paid": "Dividend",
            "Common Shares Outstanding": "Shares Outstanding",
            "Inventories": "Inventories",
            "Total Current Assets": "Total Current Assets",
            "Total Assets": "Total Assets",
            "Short Term Debt": "Short Term Debt",
            "Total Current Liabilities": "Total Current Liabilities",
            "Long Term Debt": "Long Term Debt",
            "Total Liabilities": "Total Liabilities",
            "Total Equity": "Total Equity",
            "Net Income/Starting Line": "Net Income/Starting Line",
            "Net Cash From Acquisitions & Divestitures": "Net Cash from Acquisitions & Divestitures",
            "Other Change in Fixed Assets & Intangibles": "Change in Other",
            "Share Capital & Additional Paid-In Capital": "Share Capital & Additional Paid-In Capital",
            "Other Share Capital": "Shares (Diluted)_income",
            "Common Stock": "Shares (Diluted)_cashflow",
            "Depreciation & Amortization": "Depreciation & Amortization",
            "(Increase) Decrease in Accounts Receivable": "Change in Accounts Receivable",
            "Net Changes in Cash": "Net Change in Cash",
            "Cash From (Repurchase of) Equity": "Cash from (Repurchase of) Equity",
            "Net Income Available to Common Shareholders": "Net Income (Common)",
            "Change in Working Capital": "Change in Working Capital",
            "Cash from Operating Activities": "Net Cash from Operating Activities",
            "Cash from Investing Activities": "Net Cash from Investing Activities",
            "Cash from Financing Activities": "Net Cash from Financing Activities",
            "Revenue": "Revenue",
            "Cost of revenue": "Cost of Revenue",
            "Gross Profit": "Gross Profit",
            "Operating Expenses": "Operating Expenses",
            "Operating Income (Loss)": "Operating Income (Loss)",
            "Income Tax (Expense) Benefit, net": "Income Tax (Expense) Benefit, Net",
            "Net Income": "Net Income",
            "SMA_5": "SMA_5",
            "SMA_10": "SMA_10",
            "RSI_14": "RSI_14"
        })
        return df


    def compute_rsi(self, series, period=14):
        """
        Compute the Relative Strength Index (RSI) for a given price series.
        """
        delta = series.diff(1)
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def filter_selected_features(self, df, selected_features):
        """
        Create a new DataFrame using only the selected list of features.
        Ensures that only available features are selected.
        """
        if df is None or df.empty:
            print("⚠️ Warning: DataFrame is None or empty before filtering.")
            return None  # Avoid returning None if df is invalid
        
        # Check which selected features exist in df
        available_features = [feature for feature in selected_features if feature in df.columns]

        if not available_features:
            print("⚠️ Warning: No selected features are available in the DataFrame.")
            return None

        return df[available_features]  # Return filtered DataFrame
    




